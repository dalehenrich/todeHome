TDTxtLeafNode{#name:'spec',#contents:Text{#string:'New Indexing Features for GemStone Smalltalk 64bit v3.2\n                                                          [Dale Henrichs: v0.10]\n\n-------------------------------------------------------------------------------\nOVERVIEW\n-------------------------------------------------------------------------------\n\nModification Tracking\n------------------------\n\n  To implement many of the indexing features it is necessary to validate that\n  modification tracking is functional for all objects, so I think it is about\n  time to add test coverage for modification tracking independent of the \n  indexing subsystem and explicitly document any exceptions. In a nutshell this\n  involves ensuring that we have proper support for modification tracking \n  (i.e., add test coverage and correct deficiencies) for:\n\n    - dynamic instance variables,\n    - named and indexable portion of all pointer and byte objects\n    - all subclasses of UnorderedCollections\n    - all subclasses of SequencableCollections\n    - all subclasses of ByteArray\n\n  After a brief review of the C code, Allen has determined that the vast \n  majority of cases are already covered for modification tracking, with the \n  most notable exceptions being a handful of special purpose Array \n  primitives. \n\n  I have a basic modification test suite tucked away somewhere that can be \n  used as the basis for the initial set of tests.\n\nNew Index Creation API\n------------------------\n\n  The class GsIndexSpec maintains a collection of instances of subclasses \n  of AbstractIndexSpecifications. The instances of AbstractIndexSpecification\n  are created using GsIndexSpec methods, not directly. \n\n  To create an index on an nsc, one first creates an instance of GsIndexSpec \n  with one or more index specifications:\n\n    spec := GsIndexSpec new\n      equalityIndex: \'each.age\' lastElementClass: SmallInteger;\n      equalityIndex: \'each.father.firstName\' lastElementClass: String;\n      yourself.\n\n  Note that the reserved variable \"each\" is required in every index path.  \n  Using the old API, it was correct to create an index on empty string, \'\'. \n  Using the new API, the equivalent would be \'each\'.\n\n  One then uses the spec to create the indexes on an nsc:\n\n    spec createIndexesOn: nsc.\n\n  The spec is not associated with any specific nsc, so an index spec can be \n  used to create indexes on a number of collections:\n\n    spec createIndexesOn: nsc.\n    spec createIndexesOn: anotherNsc.\n\n  The spec may be used to remove a set of indexes from a collection:\n\n    spec removeIndexesFrom: nsc.\n\n  One can get also get an index spec for an nsc with the #indexSpec message:\n\n    spec := nsc indexSpec.\n\n  Printing an index spec for an nsc provides a useful \"index report\":\n\n    \'GsIndexSpec new\n      equalityIndex: \'\'each.age\'\' lastElementClass: SmallInteger;\n      equalityIndex: \'\'each.father.firstName\'\' lastElementClass: String;\n      yourself\'\n\n  You can also use the index spec for rebuilding indexes:\n\n    spec := nsc indexSpec.\n    nsc removeAllIndexes.\n    spec createIndexesOn: nsc.\n    \n  Here is the full list of index creation messages in GsIndexSpec:\n\n    equalityIndex:lastElementClass:\n    equalityIndex:lastElementClass:options:\n    identityIndex:\n    identityIndex:options:\n    unicodeIndex:collator:\n    unicodeIndex:collator:options:\n\nIndex Creation Options\n------------------------\n\nThere are three different independent options available:\n\n  reducedConflict\n  requirePathTerms\n  requireUnicodeStrings (meaningful for unicode indexes only)\n\nAny combination of the above options may be specified as  \narguments to the options keyword. Use the #, message to\ncombine multiple options:\n\n  GsIndexOptions requirePathTerms , GsIndexOptions reducedConflict\n \nCreating a reduced conflict index:\n\n GsIndexSpec new\n  equalityIndex: \'each.sons.*.numberOfChildren\'\n    lastElementClass: SmallInteger\n    options: GsIndexOptions reducedConflict;\n  unicodeIndex: \'each.lastName\'\n    collator: (IcuCollator forLocaleNamed: \'en_GB\')\n    options: GsIndexOptions reducedConflict;\n  yourself.\n\nExamples of the other options:\n\n GsIndexSpec new\n  equalityIndex: \'each.sons.*.numberOfChildren\'\n    lastElementClass: SmallInteger\n    options: GsIndexOptions requirePathTerms , \n               GsIndexOptions reducedConflict;\n  unicodeIndex: \'each.lastName\'\n    collator: (IcuCollator forLocaleNamed: \'en_GB\')\n    options:\n      GsIndexOptions requirePathTerms , \n        GsIndexOptions requireUnicodeStrings;\n  yourself\n\nNew Query API\n------------------------\n\n  The class GsQuery is used for defining and executing queries.\n  The instance of GsQuery includes a formula, which is an instance of \n  GsQueryFormula, which can be re-used in other queries.  \n  A GsQueryFormula combines predicates using operators.\n\n  The following expression:\n\n    (GsQuery fromString: \'each.age <= 18\') executeOn: nsc.\n\n  is equivalent to the following old-style select block expression:\n\n    nsc select: {:each | each.age <= 18}.\n\n  Multiple predicates are supported:\n\n    GsQuery fromString: \'(each.age <= 18) & (each.firstName = \'\'Dale\'\')\'.\n\n  The OR operator ($|) is supported, so queries like the following can be \n  executed:\n\n    GsQuery fromString: \n      \'(each.firstName = \'\'Dale\'\') & ((each.age <= 18) | (each.age > 55))\'.\n\n  The #not message is also supported. In the simple case one may write \n  queries of the form:\n\n    GsQuery fromString: \n      \'(each.firstName = \'\'Dale\'\') not\'.\n\n  The system will transform queries containing #not to an equivalent form \n  of the query without the #not, using De Morgan\'s Laws, so that optimized \n  queries may still be performed in the presence of a #not. In the above \n  simple case the query is transformed to: \n\n    GsQuery fromString: \n      \'(each.firstName ~= \'\'Dale\'\')\'.\n\n  A slightly more complex query:\n\n     GsQuery fromString: \n      \'(each.firstName = \'\'Dale\'\') & ((each.age <= 18) | (each.age > 55)) not\'.\n\n  would be transformed to the following:\n\n     GsQuery fromString: \n      \'(each.firstName ~= \'\'Dale\'\') | ((each.age > 18) & (each.age <= 55))\'.\n \n  and so on.\n\n  One may directly write range queries of the form:\n\n    GsQuery fromString: \'18 <= each.age < 50\'.\n\n  If one happens to write an `invalid` range query:\n\n    GsQuery fromString: \'18 > each.age < 50\'.\n\n  The system correctly recognizes that fact and the query is converted to a \n  valid form.\n\n    GsQuery fromString: \'(18 > each.age) & (each.age < 50)\'.\n\n  This conversion occurs during GsQuery creation, before the optimize step.\n\n  Query Variables\n  ---------------\n\n  One may write queries using variables, so the above query could have been\n  written as:\n\n    GsQuery fromString: \'min <= each.age < max\'.\n\n  Variable values are bound to the query variables using the #bind:to: \n  message:\n\n    (GsQuery fromString: \'min <= each.age < max\')\n      bind: \'min\' to: 18;\n      bind: \'max\' to: 50;\n      executeOn: nsc.\n\n  Basic Query Functions\n  ---------------------\n\n  #executeOn: causes a query result to be calculated for the given `nsc`.\n  #executeOn: is a convenience method for the following standard sequence:\n\n    (GsQuery fromString: \'(each.firstName ~= \'\'Dale\'\')\')\n      on: nsc;\n      optimize;\n      execute.\n\n  The #on: message binds an `nsc` to the query and evaluators are bound to\n  each predicate in the query formula. After binding an `nsc`, the message \n  #hasIndexEvaluators can be used to determine if each of the predicates\n  is using an index on the nsc.\n\n  The #optimize message performs a number of optimizations on the query \n  formula. A query may be sent the #optimize message before being bound to \n  an nsc using the #on: message, however some optimizations cannot be \n  performed without an bound nsc. Similarly, a query may be sent the #\n  optimize message before variable values are bound, but some \n  optimizations may not be performed.\n\n  Here\'s a list of the optimizations performed:\n\n    - convert clauses modified by `not` using De Morgan\'s Laws\n\n          (each.firstName = \'Dale\') not\n\n        becomes:\n\n          (each.firstName ~= \'Dale\')\n\n    - convert predicates with common path-path operands to an equivalent\n      constant predicate\n\n          (each.firstName = each.firstName) \n\n        becomes:\n\n          (true)\n\n    - replace constant-path predicates with equivalent path-constant \n      predicates\n\n          (19 > each.age) \n\n        becomes:\n\n          (each.age < 19)\n\n    - eliminate redundant predicates. i.e., predicates that fall within range\n      of other predicates\n\n          (each.age < 19) & (each.age < 4)\n\n        becomes:\n\n          (each.age < 4)\n\n        Note that elimination of redundant predicates requires that any \n        variables in the query be bound to values.\n\n    - convert 2 path-constant predicates into a range predicate when possible\n\n          (each.age > 4) & (each.age < 19)\n\n        becomes:\n\n          (4 < each.age < 19)\n\n        Note that elimination of redundant predicates requires that any \n        variables in the query be bound to values.\n\n    - reorder predicates based on following ordering rules:\n        constant predicates\n        indexed predicates\n        identity comparison predicates\n        equality comparison predicates\n        all others\n\n          (each.age <= 21) & (each.gender == #male) & \n          (each.name = \'Dale\') & (each.father = each.father)\n\n        assuming each.name is indexed and each.age is not indexed, becomes:\n\n          (true) & (each.name = \'Dale\') & \n          (each.gender == #male) & (each.age <= 21)\n\n        Note that some of the reordering optimizations require an nsc and \n        any variables to be bound to the query.\n\n    - consolidate path-constant predicates to single enumerated predicate\n      if an index exists that has an enumerated path term and predicates\n      using the enumerated path  term can be combined into a single \n      predicate\n\n          (each.firstName = \'Martin\') | (each.lastName = \'Martin\')\n\n        becomes:\n\n          (each.firstName|lastName = \'Martin\')\n\n        Note that some of the consolidation optimizations require an nsc and \n        any variables to be bound to the query.\n\n  Original Formula\n  ----------------\n\n  The #optimize message may transform the query formula beyond recognition. If\n  one wants to review and understand the optimizations performed, one must be\n  able to view the original formula used to create the query.\n\n  The GsQuery instance records the original formula and makes it available via\n  the #originalFormula message. \n\n  When the original formula is recorded all of the bound state is removed\n  (nsc, bound variable values, etc.) so that stale values are not kept alive.\n  \n  If one wants to create a new query from an original formula do the following:\n\n    query := GsQuery \n      fromString: \'(each.numberOfChildren < 4) & (2 < each.numberOfChildren)\'.\n    query \n      one: nsc;\n      optimize.\n    originalFormula := query originalFormula.\n    originalQuery := GsQuery fromFormula: originalFormula.\n\n  Query Execution\n  ---------------\n\n  The #execute message causes the query result to be calculated. Note that\n  I have chosen not to use #select, because we are not using a block to \n  perform the query. Using #select would tend to imply that #reject and \n  #detect would be supported.\n\n  Reject functionality can be achieved by forming the query using `not`:\n\n    (each.firstName = \'Dale\') not\n\n  or by `negating` the query formula itself:\n\n    query := GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\'.\n    negatedQuery := GsQuery fromFormula: query formula not. \n    rejectEquivalent := negatedQuery executeOn: nsc.\n\n  Detect functionality can be achieved by using #do: or #do:for: and \n  exiting the block early:\n\n    (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\n      do: [:each | ^each]\n      on: nsc\n\n  where the #do:on: message is a shortcut for the following sequence:\n\n    (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\n      on: nsc;\n      optimize;\n      do: [:each | ^each]\n\n  Detect:ifNone: functionality can be achieved by using #do:ifEmpty: or \n  #do:ifEmpty:for: as follows:\n\n    (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\n      do: [:each | ^each]\n      ifEmpty: [self error: \'No elements matched the query\' ]\n      on: nsc\n\n  Query Streams\n  -------------\n\n  To stream over the results of query one may use #readStream, \n  #readStreamOn:, #reversedReadStream, and #reversedReadStreamOn:. For\n  example:\n\n    stream := (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\n      readStreamOn: nsc.\n    [ stream atEnd ] whileFalse: [ \n\t  element := stream next.\n\t  \"...\" ].\n\n  #readStreamOn: is similar to #executeOn: in that it is a short cut for \n  the longer query form which includes explicit calls to #on:, #optimize \n  and variable binding:\n\n    query := (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\n      on: nsc;\n      optimize.\n    stream := query readStream.\n    [ stream atEnd ] whileFalse: [ \n\t  element := stream next.\n\t  \"...\" ].\n\n  There are similarities between the #do:* and #*readStream* families of\n  evaluation, but I have not yet determined what level of implementation \n  sharing there will be between them. \n\n  Invariance and Queries\n  -------------\n\n  All instances of GsQueryFormula and its subclasses created through the public\n  API are invariant. By making the instances invariant, we are making it safe\n  for query formulas to be persisted and shared without fear that side \n  effects of message sends may change the semantics of the query. \n\n  Given the following formula:\n  \n    (each.age > min) & (each.age < max)\n\n  the optimized form of the query will vary depending upon the value `min` and\n  `max`. If `min=4` and `max=9`:\n\n    (GsQuery fromString: \'(each.age > min) & (each.age < max)\')\n      bind: \'min\' to: 4;\n      bind: \'max\' to: 9;\n      on: nsc;\n      optimize.\n\n  The formula will be optimized to:\n\n    (4 < each.age < 9)\n\n  If the `min=9` and `max=4`:\n\n    (GsQuery fromString: \'(each.age > min) & (each.age < max)\')\n      bind: \'min\' to: 9;\n      bind: \'max\' to: 4;\n      on: nsc;\n      optimize.\n\n  The formula will be optimized to:\n\n    (false)\n\n  as there are no values of `each.age` that can satisfy the query.\n\n  It is important to note that there are no plans to allow the effects of\n  optimizations to be reversed.\n\n  Consequently the form of the formula depends upon which part of the\n  life cycle the formula is accessed. The fact that all formulas are \n  invariant simply means that the following sequence of operations are \n  safe:\n\n    query := GsQuery fromString: \'(each.age > min) & (each.age < max)\'.\n    savedFormula := query formula.\n    query\n      bind: \'min\' to: 9;\n      bind: \'max\' to: 4;\n      on: nsc;\n      optimize.\n    newQuery := GsQuery fromFormula: savedFormula.\n    newQuery\n      bind: \'min\' to: 4;\n      bind: \'max\' to: 9;\n      on: nsc;\n      optimize.\n    anotherFormula := newQuery formula.\n    anotherQuery := anotherFormula asQuery\n    anotherQuery\n      bind: \'min\' to: 3;\n      bind: \'max\' to: 30;\n      on: nsc;\n      optimize.\n    finalQuery := anotherFormula asQuery\n    finalQuery\n      bind: \'min\' to: 30;\n      bind: \'max\' to: 3;\n      on: nsc;\n      optimize.\n\n  Instances of GsQuery are not normally invariant. If one wants to share \n  a query, use the #immediateInvariant message.\n\n  Backwards compatibility with SelectBlock-based queries.\n  -------------\n\n  One may transition to using the GsQuery api while continuing to use \n  SelectBlocks. For example the following four statements:\n\n    | min max |\n    min := 6.\n    max := 55.\n    nsc select: {:each | (each.age > min) & (each.age < max)}.\n    \n    (GsQuery \n      fromSelectBlock: {:each | (each.age > min) & (each.age < max)})\n        executeOn: nsc.\n\n    (GsQuery \n      fromSelectBlock: {:each | (each.age > min) & (each.age < max)}\n      on: nsc) execute.\n\n    (GsQuery fromString: \'(each.age > min) & (each.age < max)\')\n      bind: \'min\' to: min;\n      bind: \'max\' to: max;\n      executeOn: nsc.\n\n  produce exactly the same results. \n\n  Given the mechanism used to extract the query formula from a SelectBlock, \n  it is not possible to alter the variable bindings after the fact as it \n  would be using a query statement. So the following does not work:\n\n    (GsQuery \n      fromSelectBlock: {:each | (each.age > min) & (each.age < max)})\n        bind: \'min\' to: 3;\n        bind: \'max\' to: 9;\n        on: nsc;\n        optimize;\n        execute.\n\n  There are no plans to deprecate the current SelectBlock-based query API \n  (#select:, #detect:, #reject: etc.).\n  \nSet-valued Path Term\n------------------------\n\n  When the indexing code was ported to the 64-bit server, the support for \n  Set-valued path terms was not carried forward. Over time it has become clear\n  that allowing index paths to include collections is a desirable feature, so\n  we will add support for Set-valued path terms in version 3.2.\n\n  An asterisk in the path term of a selection block predicate indicates that a\n  collection is expected at that point in the path:\n\n    GsIndexSpec new\n      equalityIndex: \'each.children.*.age\' lastElementClass: SmallInteger;\n      createIndexesOn: myEmployees.\n    (GsQuery fromString: \'each.children.*.age <= 18\')\n      executeOn: myEmployees.\n\n  The select block sytax will be extended to allow \'*\' in path terms in order\n  to maintain compatibility with existing 32 bit usage:\n\n    myEmployees select: {:each | each.children.*.age <= 18 }\n\n  The query will examine all elements of collection `children`.  In the \n  32-bit server, the collection path terms were restricted to instances of \n  UnorderedCollection. For the 64-bit implementation we will consider defining\n  a set of SAFE collections. Right now, UnorderedCollection is the only member\n  of the SAFE collection set.\n\n  An asterisk my be used in any position in the path.\n\n  If an asterisk is present in the path term when an index is created, changes\n  to the underlying collection will be tracked and the index objects will be\n  automatically updated.\n\nEnumerated Path Term\n------------------------\n\n  An Enumerated Path Term is a list of instance variable names.\n\n  The list of instance variables are specified as a `|` delimited list of \n  instance variable names:\n\n    GsIndexSpec new\n      equalityIndex: \'each.firstName|lastName\' lastElementClass: String;\n      createIndexesOn: myEmployees.\n    (GsQuery fromString: \'each.firstName|lastName = name\')\n      bind: \'name\' to: \'Allen\';\n      executeOn: myEmployees.\n\n  The value of each instance variable listed in the path term will be \n  considered in the query. Changes to either of the instance variables will\n  be tracked and the index objects will be automatically updated.\n\nSelector Path Term\n------------------------\n\n  As another specialization of a Named Path Term (standard PathTerm class), if a\n  Path Term is qualified with the `selector` keyword, the the path term is used\n  as a selector and the result of the message send is to be traversed by the \n  query. The `selector` keyword is denoted by a leading `#` character in the path\n  term:\n\n    GsIndexSpec new\n      equalityIndex: \'each.#car.color\' lastElementClass: String;\n      createIndexesOn: myEmployees.\n    (GsQuery fromString: \'each.#car.color = color\')\n      bind: \'color\' to: \'blue\';\n      executeOn: myEmployees.\n\n  The query will send the message `car` to each element of `myEmployees` and then \n  access the `color` instance variable of the result.\n\n  We cannot automatically maintain dependendencies and update indexes as the \n  elements at that location change, but a user can use the modification tracking \n  api to do this. \n\n  The `selector` qualifier may be used with any named path term position.\n\nHeterogeneous Collections\n------------------------\n\n  The new indexing API supports queries and indexes on heterogenous collections. A\n  heterogenous collection is a collection in which not all members of the collection\n  share the same instance variable structure as defined by the path elements in a \n  query or the path terms in an index specification. \n\n  In earlier versions of the product, when executing a query on a heterogeneous \n  collection, building an index on a heterogeneous collection or adding a \n  heterongeneous object to homogeneous collection; an #rtErrObjectInvalidOffset \n  error was unconditionally signalled upon encountering an instance without the\n  expected named instance variable.\n\n  In 3.2, an #rtErrObjectInvalidOffset error will still be signalled when using the \n  old indexing API for index creation. However, when using the new API the default \n  is to permit indexes on heterogenous collections.\n\n  The #requireAllPathTerms message may be used to enforce the restriction that all \n  queried instances are homogenous with respect to the path terms. Index creation \n  using the #requirePathTerms: keyword may be used to specify that only particular \n  instance variable paths should be homogenous. When a path is specified as \n  requiring path terms, all pathterm on the path are required.\n\n  Here are examples for creating indexes, controlling for the presence of \n  heterogeneous elements in the collection:\n \n    GsIndexSpec new\n      requireAllPathTerms;\n      equalityIndex: \'each.age\' lastElementClass: SmallInteger;\n      equalityIndex: \'each.father.middleName\' lastElementClass: String;\n\t   createIndexesOn: nsc.\n\n    GsIndexSpec new\n      equalityIndex: \'each.age\'\n        lastElementClass: SmallInteger\n        requirePathTerms: false;\n      equalityIndex: \'each.father.middleName\' \n        lastElementClass: String\n        requirePathTerms: true;\n      identityIndex: \'each.father\' \n         requirePathTerms: true;\n\tcreateIndexesOn: nsc.\n\n  Note that in that case where a required path term is a prefix of a\n  heterogeneous path, the required path will be applied to both indexes:\n\n    GsIndexSpec new\n      equalityIndex: \'each.father.middleName\' \n        lastElementClass: String\n        requirePathTerms: false;\n      identityIndex: \'each.father\' \n         requirePathTerms: true;\n\t   createIndexesOn: nsc.\n\n  In the case above the \'father\' instance variable is required and the \n  \'middleName\' instance variable is optional.\n\n  On the other hand, if a required path term wholly encompasses a \n  heterogeneous path, an error will be signalled. The following is an\n  example of this case:\n\n   GsIndexSpec new\n      equalityIndex: \'each.father.middleName\' \n        lastElementClass: String\n        requirePathTerms: true;\n      identityIndex: \'each.father\' \n         requirePathTerms: false;\n      createIndexesOn: nsc.\n\n\nDateTime and DateAndTime\n------------------------\n\n  In both the 32-bit and 64-bit servers, indexes created with a Last Element \n  Class of DateTime or DateAndTime do not use encryption values, thus query\n  operations on instance of the two classes are not as efficient as they \n  could be.\n\n  Martin suggests that both DateTime and DateAndTime should be encrypted by \n  converting the date and time information into signed UTC microseconds since \n  an epoch. The second encryption word with a full SmallInteger range will be \n  used to store the microseconds value. \n\n  For DateTime, UTC microseconds represents the exact value of the `seconds`\n  instance variable, since the resolution for DateTime is in milliseconds.\n\n  The DateAndTime class can use different Number instances to get different\n  levles of resolution (i.e., ScaledDecimal, SmallDouble or Integer) so \n  microseconds may not provide an exact representation.  Therefore the first \n  encrcryption word will have a handful of bytes allocated to indicate whether \n  or not the signed microseconds represents an exact match or is within a \n  microsecond of the exact value.\n\nUnicode String Indexes\n------------------------\n\n  In 3.1 we added support for Unicode strings, but deferred indexing support\n  until a later date ... that date has arrived.\n\n  Unicode string methods take a Unicode collator object (derived from a \n  Locale) to perform primitive string comparison operations. To create an index\n  that uses a Unicode collator the following methods will be used:\n\n    GsIndexSpec new\n      unicodeIndex: \'each.#car.color\' \n        collator: IcuCollator default;\n      rcUnicodeIndex: \'each.firstName\' \n        collator: (IcuCollator forLocaleNamed: \'en_GB\')\n        requireUnicodeStrings: true;\n      createIndexesOn: myEmployees.\n\n  The Unicode collator instance will be made invariant and attached to the \n  index metadata. \n\n  Unicode indexes have an implicit lastElementClass of CharacterCollection.\n  If requireUnicodeStrings: true, then the lastElements must be instance of\n  Unicode string classes: Unicode7, Unicode16, etc.\n\n  It is disallowed to create two Unicode indexes on the same path. Creating\n  a unicode and an equality index on the same path is not explicitly disallowed, \n  but since Unicode strings are disallowed in non-unicode equality indexes, \n  the only way this can succeed is when the index elements are all Strings.\n\n  When a collator is specified while creating a query on a path term upon\n  which an index has been created:\n\n    (GsQuery fromString: \'each.firstName = name\')\n      bind: \'name\' to: \'Allen\';\n      on: myEmployees collator: (IcuCollator forLocaleNamed: \'en_GB\');\n      execute.\n\n  and the collator for the index is #= to the collator specified in the \n  query, then the index will be used to satisfy the query. Otherwise the \n  collator specified in the query will be used for brute force evaluation.\n\n  If no collator is specified for the query, then the collator associated\n  with the index is used to satisfy the query.  For example, given the\n  index created in the above example using IcuCollator default, whatever \n  the default was at the time of index creation, that would be used for \n  the following query:\n\n    (GsQuery fromString: \'each.#car.color = color\')\n      bind: \'color\' to: \'blue\';\n      executeOn: myEmployees.\n\n  For a given Unicode string and a given Unicode collator, a Unicode sort\n  key can be produced. The bytes of the sort key are created such that two\n  sort keys can compared on a byte-wise basis, exactly what is needed for\n  the btree encryption values.\n\nConcurrent Parallel Index Creation\n------------------------\n\n  In 2.x we introduced UnorderedCollection>>createParallelIndexes: which allows\n  one to create a number of indexes on a single collection while making a \n  single pass through the the elements of the collection. \n\n  Norm has suggested that it would be very useful to spread the index creation\n  work across multiple gems. Doing so would only be safe if we can avoid\n  conflicts while updating the structures for each index (the initial creation\n  and final updates are already isolated by the \n  UnorderedCollection>>createParallelIndexes: code).\n\n  Of the index data structures that are created and modified on a per index\n  basis during index creation, only the indexDictionary is shared amongst the \n  various indexes (i.e., each equality index has it\'s own BtreeNode structure).\n  Fortunately, indexDictionary is an RcIndexDictionary, so concurrent updates \n  should be tolerated. \n\n  There are three phases of parallel index creation:\n\n    - create index structures\n    - traverse elements and add index meta data\n    - finalize index structures and update nsc\n\n  The first and third phases need to be run in a single session while the index\n  building can be run concurrently. Here is some sample code illustrating the \n  proposed api:\n\n    | nsc gem1Spec gem2Spec |\n    nsc := Set new.\n    gem1Spec := GsIndexSpec new\n      equalityIndex: \'each.age\' lastElementClass: SmallInteger;\n      yourself.\n    gem2Spec := GsIndexSpec new\n      equalityIndex: \'each.lastName\' lastElementClass: String;\n      yourself.\n    nsc createConcurrentIndexes: gem1Spec, gem2Spec.\n    nsc buildConcurrentIndexes: gem1Spec.\n    nsc buildConcurrentIndexes: gem2Spec.\n    nsc finalizeConcurrentIndexes: gem1Spec, gem2Spec.\n\n  The #buildConcurrentIndexes: would be run in separate concurrent sessions.\n\n  Note: we need to find a way to track index creation progress.\n\nWildcard String Query\n\n  Rather than add additional features to the product at this time, we will \n  instead publish a set of examples documenting the different way that the\n  existing facilities within the image can be used in support of string \n  queries. Examples will include (but not limited to):\n\n    - wildcard string queries: ?xyz, ?xyz*, xyz*\n    - examples of data structures to facilitate word-based queries (i.e., \n      return all documents that contain the word `filetree`)\n\n-------------------------------------------------------------------------------\nAPPENDIX\n-------------------------------------------------------------------------------\n\n64-bit Server Encryption/Decryption\n\n  14 bytes of encryption, 7 bytes in word0 and 7 bytes in word1. The eighth \n  byte in word0 has 5 bits (signed) reserved for type information. There are 5\n  bits that are currently unused in word1.\n\n  The RelCachedValueEType value is offset by -8 to fit in the 5 bit signed \n  integer. 18 types have already been declared (from relops.ht):\n\n  typedef enum {\n    REL_UNDEFINED_CACHE,\n    REL_SYM_CACHE,\n    REL_STR_CACHE,\n    REL_DB_SYM_CACHE,  /* DoubleByteSymbol */\n    REL_DB_STR_CACHE,  /* DoubleByteString */\n    REL_Quad_STR_CACHE,  // QuadByteString\n    REL_Quad_SYM_CACHE,  // future QuadByteSymbol\n    REL_BOOLEAN_CACHE,\n    REL_CHR_CACHE,\n    REL_TIME_CACHE,\n    REL_DATE_CACHE, \n    REL_SMALL_INT_CACHE,\n    REL_LRG_INT_CACHE,\n    REL_ScaledDecimal_CACHE,  /* Gs64 v3.0 ScaledDecimal */\n    // REL_SCALED_DECIMAL_CACHE was not used, same as REL_FRACTION_CACHE,\n    REL_FRACTION_CACHE,\n    REL_SMALL_DBL_CACHE,   /* SmallDouble */\n    REL_FLOAT_CACHE,   /* Float, SmallFloat all encrypted as doubles */\n    REL_DECIMAL_FLOAT_CACHE    /* DecimalFloat */\n    } RelCachedValueEType;\n\n------------------------\nNOTES\n------------------------\n\nSpec Review Comments (Thursday January 17, 2013)\n------------------------\n\n  1. Useful to know if a particular {} block would leverage existing indeses or\n     just end up doing a linear scan. Perhaps #selectIndexed: would throw an\n     error if no index were used.\n\n  2. Alternatives to my suggested PathTerm syntax additions were offered up and\n     deserve more attention.\n\n  3. For Selector Path Term, it was suggested that we may want to introduce a\n     flag in the vm that would allow a developer to detect whether or not a\n     particular message would cause unintended side effects. The issue being\n     that a message used in a selector path term SHOULD NOT have any side\n     effects when executed.\n\n  4. It was suggested that we allow indexing on instances of UTF8.\n\n  5. It was suggested that the Ernie ExternalSession support be moved into the\n     base in order to provide a standard mechanism for doing parallel index\n     creation.\n\n  6. It was suggested that Progress of Index Reporting be made to be consistent\n     and correct.\n\n  7. It was suggested that NamedPathTerm be called AbstractNamedPathTerm.\n\n  8. It was suggested to clarify that the negative `id` discussed in the\n     dependency list entries should be specified as an explicit `-1`.\n\nPathTerm Spec Review (Wednesday February 6, 2013)\n------------------------\n\n  This meeting was held to discuss alternatives that were suggested by\n  Martin[1] and reviewed by Dale and Richard[2].\n\n  [1] martinsStrawManPathTermSyntax.txt\n  [2] daleAndRichardsStrawManPathTermSyntax.txt\n\nIndexed Path Term\n\n  During the discussion related to the syntax for Indexed Path Terms, it was\n  decided that the use case for supporting Indexed Path Terms was marginal at\n  best. As a consequence we are recommending that Indexed Path Terms be dropped\n  from the specification.\n\nCollection-Valued Path Term\n\n  It was decided that if we are to allow the use of the indexable fields in an\n  object for Collection-Valued Path Terms, then we need to restrict their use\n  to SAFE collection classes and NSCs. Examples of SAFE collections are Array\n  and OrderedCollection. UNSAFE collections include Dictionary and RcQueue.\n\nQuery Block, Query API & Optional path terms\n\n  It was decided to construct indexes and queries for Enumerated, Optional, and\n  Selector Path Terms using a Smalltalk API rather than Path Term syntax.\n\n  To support existing 32-bit and 64-bit index creation and queries we will\n  support the old-style path terms and Query Block syntax:\n\n    a.b.c\n    a.*.c\n\n  The API will be expanded to cover optional Named Path Terms and Unicode index\n  creation.\n\nEnumerated Path Term\n\n  Enumerated Path Terms will be restricted to named variables only.\n\nOpen Questions\n\n  1. Is an error signalled by a query using a named path term on an object with\n     no instance variable with the desired name?\n\n  2. Are Set and Bag considered to be NSCs in that they can be the target of an\n     index even though their implementation is vastly different from\n     IdentityBag and friends?\n\nQuery and Index Creation APIs defined (August 2, 2013)\n------------------------\n\n  Between February 10 and the present, a fair amount of work has been done in \n  defining and implenting the Query and Index Creation APIs. \n',#runs:RunArray{#runs:[33197],#values:[[TextColor{#color:Color{#rgb:0}}]],#lastIndex:8124,#lastRun:1,#lastOffset:8123}},#creationTime:DateAndTime['2013-12-06T17:02:00.8286669254303-08:00'],#modificationTime:@9}