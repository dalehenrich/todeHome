TDTxtLeafNode{#name:'todo',#contents:Text{#string:'[x]1. rename GsQueryClause to GsQueryFormula and GsQueryFormula to \n   GsCompoundQueryClause\n[x]2. for a conjunctive clause, the first clause is evaluated using the bindings\n   for the predicates. The second clause should be evaluated against the results of\n   the first clause ... so I need a way to apply a clause against a result nsc ...\n   and ignore the bound evaluator ... or perhaps we can late bind the evaluator \n   during query evaluation?\n3. one should be able to override the default behavior described in 2, to force the\n   native evaluators and rely on set intersection to to resolve the results.\n4. I can imagine an indexed query where instead of maintaining the indexes, an \n   IdentitySet of results is maintained ... so each change to an instance variable \n   causes the result set of the query to be recalculated...so indstead of creating\n   an index on a path, an index on a query is created ... this only works if you \n   have path/constant, constant/path, or path/path predicates ... especially \n   useful for the path/path predicates.\n5. PathEvaluators by their nature will be slower than using a do loop over the \n   collection and applying the query on an element by element basis:\n     - when does the path evaluator make sense?\n       -- when you want to evaluate the query on a predicate by predicate\n          basis ... need to find a use case for this: no indexes but faster...\n          it may turn out that the path evaluators never make sense?\n     - when does it make sense use a do loop? \n       -- whenever the developer determines it\'s faster to apply the entire\n          predicate to each element. \n[x]     - I should be able to evaulate a query in a do loop by passing in each \n       object and resolving all of the terms from that... \n6. For the indexed queries (4), one could index the result set!#$?\n7. A predicate could be bound to a constant nsc ... allowing one to use the nsc as \n   a filter (conjunctive clause) in the query ... disjunctive clauses less \n   interesting\n8. change #null in GsUnaryClause to #noop\n9. the unary constant predicates `false &...`, `false |...`, `true &...`, `true |...` should be further optimized ...\n10. Enumerated and Selector path terms not implemented.\n11. Optional path term implmented for non-indexed query execution only.\n12. requiredPathTerms and unicode indexes not implemented.\n13. Date and DateAndTime index optimization not implemented.\n14. Concurrent parallel index creation not implemented.\n[x]15. #, operation for GsIndexSpec ... concatenate the lists...\n[x]16. replacement for #asCollection\n[x]17. immediate optimize (class creation specify different default optimizer)\n18. delete methods from base:\n    - PathEvaluator>>findAllValuesWithComparison:to:\n    - PathEvaluator>>_findAllValuesWithComparison:to:\n19. Need tests to compare collect: vs asCollection results for each of the \n    operators in path/constant predicates and range predicates ... see\n    IXGsClassicQueryBlockOptimizerTests>>testRemoveRedundant15 for one \n    example ... this is where I saw the initial problem\n20. Remove redundant predicates can be done based on variable names and variable\n    values\n[x]21. repackage to allow parallel work to go on ... either that or fix merge tools',#runs:RunArray{#runs:[93,1,2088,366,1,619,1,82],#values:[[],[TextEmphasis{#emphasisCode:1,#setMode:true}],@6,[TextColor{#color:Color{#rgb:0}}],[@10,TextEmphasis{#emphasisCode:1,#setMode:true}],[@10],[@10,TextEmphasis{#emphasisCode:1,#setMode:true}],@14],#lastIndex:3170,#lastRun:8,#lastOffset:0}},#creationTime:DateAndTime['2013-12-06T17:02:00.96756291389465-08:00'],#modificationTime:@17}