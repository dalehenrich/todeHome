TDTxtLeafNode{#name:'coverage',#contents:Text{#string:'Need coverage for:
  GsIndexOptions
    requirePathTerms
    requireUnicodeStrings
  GsIndexSpec printing with options...
  Auditing...
  streaming...
    GsQuery>>readStream GsQuery>>readStreamOn: aCollection
    executes the query, returning a read stream on the results.
      GsQuery>>reversedReadStream 
       GsQuery>>reversedReadStreamOn: aCollection
    executes the query, returning a read stream on the results in reversed order.       For example:
            stream := (GsQuery
               fromString: \'each.needsUpdate = true\'
               on: myEmployees) readStream.
            [stream atEnd] whileFalse: [
               | anEmployee |
               anEmployee := stream next.
               anEmployee performUpdate.
               ].
  postCopy sent on copy in base?
  GsQuery>>asSet and GsQuery>>asArray documented....
  I think that the queryOptions (and collator) need to become invariant
    when the query is made invariant...
  Need to add \'*\' back into the selectBlock syntax...
  Restore #requireAllPathTerms to the GsIndexSpec
  Can probably justify GsIndexSpec>>unicodeIndex: that creates unicode indexes
    using default collator...
  Make sure we can pick up and preserve the collator that is used for creating 
    unicode indexes when we use asIndexSpec(?)...printing the collator may be
    problematic unless the name is embedded in the collator itself...
  Make sure this optimization is done (removeUnaryConstantPredicates):
    Remove unary constant predicates
    Other optimizations may result in predicates that are unary constants true or  
    false. These are removed, or the entire expression is simplified, depending on 
    the logic.
      (true) & <other predicates> becomes: <other predicates> (true) | 
          <otherpredicates> becomes: (true)
      (false) & <other predicates> becomes: (false)
      (false) | <other predicates> becomes: <other predicates>
    For example:
      (true) & (each.name = \'Dale\') & (each.gender == #male)
    becomes:
      (each.name = \'Dale\') & (each.gender == #male)
-------------------------
  ',#runs:RunArray{#runs:[151,609,325,352,1,625,27,2],#values:[[],[TextColor{#color:Color{#rgb:0}}],@6,[TextColor{#color:Color{#rgb:0}}],[@11,TextEmphasis{#emphasisCode:1,#setMode:true}],@10,@6,[TextColor{#color:Color{#rgb:0}}]],#lastIndex:nil,#lastRun:nil,#lastOffset:nil}},#creationTime:DateAndTime['2013-12-24T21:07:54.89240503311157-08:00'],#modificationTime:DateAndTime['2013-12-26T11:35:20.04795503616333-08:00']}